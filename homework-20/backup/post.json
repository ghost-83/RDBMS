[
    {
        "id": 4,
        "title": "Samba server",
        "text": "ntcn",
        "author": "admin",
        "userId": 1,
        "category": "linux",
        "image": "samba_server.webp",
        "create": "30.08.2022 11:08:06",
        "update": "30.08.2022 11:08:06",
        "active": true
    },
    {
        "id": 3,
        "title": "Как перенести / переместить образ Docker в другую систему?",
        "text": "В идеальном случае передача изображений Docker осуществляется через реестр Docker или через полностью управляемого поставщика, такого как AWS ECR или Google GCR. Вы можете легко загрузить изображение с помощью команды docker push , а другие могут получить изображение с помощью команды docker pull .\n</p>\n<p class=\"gp\">\nХотя, если вам нужно переместить изображение с одного хоста на другой, чтобы протестировать его перед отправкой в производственную среду, или вы хотите поделиться этим изображением с кем-то в офисе, это можно сделать, экспортировав изображение как .tar файл.\n</p>\n<p class=\"gp\">\nDocker поддерживает два разных типа методов для сохранения изображений контейнера в один архив.\n</p>\n<ui>\n<li>Docker save - Save используется для сохранения изображения (не контейнера)</li>\n<li>Docker export - Export используется для сохранения контейнера (не изображения)</li>\n</ui>\n<h1 class=\"gh\">\nИспользование Docker Save Command:\n</h1>\n<h3 class=\"gh\">\nСохранение изображения Docker:\n</h3>\n<p class=\"gp\">\nВо-первых, мы будем придерживаться плана, который сохраняет только изображение. Теперь пройдемся по команде docker save . Предположим, вам нужен образ Python с Alpine, который можно извлечь из Docker Hub:\n</p>\n<pre>\n<code class=\"java\">\n    $ docker pull python:2.7.17-alpine3.9\n    2.7.17-alpine3.9: Pulling from library/python\n    e7c96db7181b: Already exists\n    1819f4b92bc2: Already exists\n    8061b3761cb3: Pull complete\n    73aebae115de: Pull complete\n    Digest: sha256:5f6059d78f530c3c59c4842e104ddcfc772a27fb8fac0d900f4d77bcb4621d9b\n    Status: Downloaded newer image for python:2.7.17-alpine3.9\n    docker.io/library/python:2.7.17-alpine3.9\n</code>\n</pre>\n<p class=\"gp\">\nПосле добавления нескольких файлов или внесения изменений в контейнер вы решаете создать архив изображения, чтобы предоставить его коллеге. Вы можете достичь этого, выполнив следующую команду:\n</p>\n<pre>\n<code class=\"java\">\n    $ docker save python:2.7.17-alpine3.9 > /path/to/save/my-python-container.tar\n</code>\n</pre>\n<p class=\"gp\">\nПросто убедитесь, что вы используете точное имя изображения и тег при создании tar. В нашем случае так и было python:2.7.17-alpine3.9 . Вы можете проверить, сработала ли вышеуказанная команда:\n</p>\n<pre>\n<code class=\"java\">\n    $ du -h my-python-container.tar\n    75M my-python-container.tar\n</code>\n</pre>\n<h3 class=\"gh\">\nЗагрузка изображения докера:\n</h3>\n<p class=\"gp\">\nКак только на целевой машине будет файл .tar , вы можете загрузить образ в локальный реестр, используя команду docker load :\n</p>\n<pre>\n<code class=\"java\">\n    $ docker load < my-python-container.tar\n</code>\n</pre>\n<p class=\"gp\">\nТеперь проверьте, есть ли у вас это изображение на целевом компьютере, с помощью docker images или docker image list . Конечный результат будет примерно таким:\n</p>\n<h1 class=\"gh\">\nИспользование команды экспорта Docker:\n</h1>\n<h3 class=\"gh\">\nЭкспорт Docker-контейнера:\n</h3>\n<p class=\"gp\">\nПримечание. Команда docker export не будет экспортировать содержимое тома, который прикреплен к контейнеру. В этом случае вам необходимо выполнить дополнительную команду для резервного копирования, восстановления или миграции существующего тома.\n</p>\n<p class=\"gp\">\nПосмотрев на метод docker export , сначала мы потянем альпийское изображение:\n</p>\n<pre>\n<code class=\"java\">\n    $ docker pull alpine\n    Using default tag: latest\n    latest: Pulling from library/alpine\n    e6b0cf9c0882: Pull complete\n    Digest: sha256:2171658620155679240babee0a7714f6509fae66898db422ad803b951257db78\n    Status: Downloaded newer image for alpine:latest\n    docker.io/library/alpine:latest\n</code>\n</pre>\n<p class=\"gp\">\nТеперь вы можете запустить экземпляр в режиме отсоединения, чтобы контейнер не разрушался при выходе из него.\n</p>\n<pre>\n<code class=\"java\">\n    $ docker run -it --detach --name alpine-t alpine\n</code>\n</pre>\n<p class=\"gp\">\nЧтобы получить идентификатор контейнера и имя, которое мы создали, мы можем использовать команду docker ps. На всякий случай, если на вашей машине контейнер был остановлен по какой-либо причине, вы все равно можете получить идентификатор и имя, используя docker ps -a :\n</p>\n<pre>\n<code class=\"java\">\n    $ docker ps\n    CONTAINER ID  IMAGE  COMMAND   CREATED         STATUS        PORTS    NAMES\n    35f34fabfa84  alpine \"/bin/sh\" 14 seconds ago  8 seconds ago           alpine-t\n</code>\n</pre>\n<p class=\"gp\">\nКак мы видим, наш идентификатор контейнера 35f34fabfa84 (он будет другим для вас), или вы также можете использовать имя контейнера; в нашем случае это alpine-t . Теперь мы можем запустить команду docker export для экспорта изображения экземпляра:\n</p>\n<pre>\n<code class=\"java\">\n    $ docker export 35f34fabfa84 > alpine-t.tar\n</code>\n</pre>\n<p class=\"gp\">\nКроме того, вы также можете использовать OPTIONS, чтобы сделать то же самое, и ваш файл .tar будет готов для передачи.\n</p>\n<pre>\n<code class=\"java\">\n    $ docker export 35f34fabfa84 > alpine-t.tar\n    $ docker export --output=\"alpine-t.tar\" 35f34fabfa84\n</code>\n</pre>\n<h3 class=\"gh\">\nИмпорт Docker-контейнера:\n</h3>\n<p class=\"gp\">\nТеперь вы можете импортировать файл .tar на целевой компьютер, используя импорт докера:\n</p>\n<pre>\n<code class=\"java\">\n$ sudo tar -c alpine-t.tar | docker import - alpine-t\n</code>\n</pre>\n<p class=\"gp\">\nЧтобы проверить, вы можете запустить контейнер с помощью --rm (он уничтожит контейнер, как только вы его выполните):\n</p>\n<pre>\n<code class=\"java\">\n    $ docker run --rm -it --name alpine-test alpine-t:[TAG]\n</code>\n</pre>",
        "author": "ghost",
        "userId": 2,
        "category": "docker",
        "image": "minions.jpg",
        "create": "23.06.2022 18:48:06",
        "update": "28.08.2022 09:45:34",
        "active": true
    },
    {
        "id": 2,
        "title": "Как создать виртуальную среду Python",
        "text": "<p class=\"gp\">\nЕсли вы похожи на меня и у вас есть десятки различных проектов Python, управление правильными пакетами, библиотеками и версиями и их поддержка могут стать настоящей проблемой. Зависимости одного проекта могут отличаться от другого, или определенные версии библиотек могут не подходить для конкретной кодовой базы. Использование виртуальных сред — отличный способ организовать ваши проекты и отделить их друг от друга. Они используются по разным причинам: от изоляции зависимостей вашего проекта до обеспечения согласованности версий пакетов и создания отдельных сред для подготовки и производства.\n</p>\n<p class=\"gp\">\nВ этом руководстве мы будем создавать виртуальную среду для простого проекта Python. Мы будем использовать модуль venv, который включен в Python 3.6 и выше. Если вы используете более раннюю версию Python, можно использовать модуль virtualenv.\n</p>\n<p class=\"gp\">\nДавайте начнем!\n</p>\n<h3 class=\"gh\">\nУстановка venv\n</h3>\n<p class=\"gp\">\nvenv должен быть установлен по умолчанию с Python 3.6 или выше, но если он не установлен, вы можете сделать это с помощью команды:\n</p>\n<pre>\n<code class=\"sh\">\n    pip install venv\n</code>\n</pre>\n<h3 class=\"gh\">\nСоздание виртуальной среды\n</h3>\n<p class=\"gp\">\nПосле установки вы можете создать виртуальную среду с помощью команды:\n</p>\n<pre>\n<code class=\"sh\">\n    python -m venv env_name\n</code>\n</pre>\n<p class=\"gp\">\nЗдесь env_name имя папки виртуальной среды — это может быть любое имя, которое вы хотите. После запуска этой команды вы увидите, что папка создана env_name.\n</p>\n<p class=\"gp\">\nЭтот каталог содержит все необходимые файлы и папки для запуска вашей виртуальной среды. Самый важный файл — это файл env.py, содержащий конфигурацию вашей виртуальной среды. Внутри папки env_name вы также найдете копию интерпретатора Python, а также исполняемые файлы pip и setuptools\n</p>\n<h3 class=\"gh\">\nАктивация виртуальной среды\n</h3>\n<p class=\"gp\">\nСледующим шагом будет активация виртуальной среды. В зависимости от вашей ОС и используемого интерфейса командной строки имена каталогов могут немного отличаться. Чтобы активировать виртуальную среду в Linux, выполните следующую команду:\n</p>\n<pre>\n<code class=\"sh\">\n    source env_name/bin/activate\n</code>\n</pre>\n<p class=\"gp\">\nЕсли вы используете Windows CMD, вам нужно будет изменить команду на:\n</p>\n<pre>\n<code class=\"sh\">\n    source env_name/Scripts/activate\n</code>\n</pre>\n<p class=\"gp\">\nКак только виртуальная среда активна, вы сможете увидеть имя над командной строкой или проверив переменную среды VIRTUAL_ENV с помощью:\n</p>\n<pre>\n<code class=\"sh\">\n    echo $VIRTUAL_ENV\n</code>\n</pre>\n<p class=\"gp\">\nТеперь, когда виртуальная среда активна, вы можете свободно устанавливать библиотеки и пакеты. Если вы хотите увидеть, какие версии установлены в данный момент, вы можете запустить:\n</p>\n<pre>\n<code class=\"sh\">\n    pip freeze\n</code>\n</pre>\n<p class=\"gp\">\nЭтот список распечатываемых библиотек и версий специфичен для этой виртуальной среды. Преимущество заключается в том, что вы можете использовать разные версии для проекта без необходимости менять версию пакета для каждой другой версии, что может вызвать проблемы.\n</p>\n<p class=\"gp\">\nВы также можете деактивировать виртуальную среду после завершения, просто запустив deactivate из любого места в каталоге.\n</p>\n<h3 class=\"gh\">\nВыводы\n</h3>\n<p class=\"gp\">\nВиртуальные среды — это важные инструменты для изоляции зависимостей вашего проекта друг от друга. Имея отдельные установки пакетов и двоичных файлов, каждый проект стоит сам по себе, и вы избежите поломки одного проекта обновлениями из другого.\n</p>",
        "author": "ghost",
        "userId": 2,
        "category": "python",
        "image": "python.png",
        "create": "23.06.2022 18:50:37",
        "update": "28.08.2022 09:45:34",
        "active": true
    },
    {
        "id": 1,
        "title": "Команды Linux: расширенный справочник команд Unix / Linux",
        "text": "<p class=\"gp\">\n    Большинство UNIX-like систем обладают встроенной справкой, которая подробно описывает все доступные команды. Однако\n    чтобы воспользоваться этой справкой, вы должны знать, по крайней мере, название команды, о которой вы хотите\n    получить информацию. Поскольку большинство пользователей только в общих чертах понимают, что они хотят сделать, то,\n    как правило, встроенная справка мало полезна новичкам.\n</p>\n<p class=\"gp\">\n    Этот справочник поможет пользователям, знающим, что они хотят сделать, найти соответствующую команду Linux по\n    краткому описанию.\n</p>\n<h3 class=\"gh\">\n    Системная информация:\n</h3>\n<ui>\n    <li><b>arch или uname -m:</b> отобразить архитектуру компьютера</li>\n    <li><b>uname -r:</b> отобразить используемую версию ядра</li>\n    <li><b>dmidecode -q:</b> показать аппаратные системные компоненты — (SMBIOS / DMI)</li>\n    <li><b>hdparm -i /dev/hda:</b> вывести характеристики жёсткого диска</li>\n    <li><b>hdparm -tT /dev/sda:</b> протестировать производительность чтения данных с жёсткого диска</li>\n    <li><b>cat /proc/cpuinfo:</b> отобразить информацию о процессоре</li>\n    <li><b>cat /proc/interrupts:</b> показать прерывания</li>\n    <li><b>cat /proc/meminfo:</b> проверить использование памяти</li>\n    <li><b>cat /proc/swaps:</b> показать файл(ы) подкачки</li>\n    <li><b>cat /proc/version:</b> вывести версию ядра</li>\n    <li><b>cat /proc/net/dev:</b> показать сетевые интерфейсы и статистику по ним</li>\n    <li><b>cat /proc/mounts:</b> отобразить смонтированные файловые системы</li>\n    <li><b>lspci -tv:</b> показать в виде дерева PCI устройства</li>\n    <li><b>lsusb -tv:</b> показать в виде дерева USB устройства</li>\n    <li><b>date:</b> вывести системную дату</li>\n    <li><b>cal 2007:</b> вывести таблицу-календарь 2007-го года</li>\n    <li><b>date 041217002007.00*:</b> установить системные дату и время ММДДЧЧммГГГГ.СС (МесяцДеньЧасМинутыГод.Секунды)\n    </li>\n    <li><b>clock -w:</b> сохранить системное время в BIOS</li>\n</ui>\n<h3 class=\"gh\">\n    Остановка системы:\n</h3>\n<ui>\n    <li><b>shutdown -h now или init 0 или telinit 0:</b> остановить систему</li>\n    <li><b>shutdown -h hours:minutes &:</b> запланировать остановку системы на указанное время</li>\n    <li><b>shutdown -c:</b> отменить запланированную по расписанию остановку системы</li>\n    <li><b>shutdown -r now или reboot:</b> перегрузить систему</li>\n    <li><b>logout:</b> выйти из системы</li>\n</ui>\n<h3 class=\"gh\">\n    Файлы и директории:\n</h3>\n<ui>\n    <li><b>cd /home:</b> перейти в директорию '/home'</li>\n    <li><b>cd ..:</b> перейти в директорию уровнем выше</li>\n    <li><b>cd ../..:</b> перейти в директорию двумя уровнями выше</li>\n    <li><b>cd:</b> перейти в домашнюю директорию</li>\n    <li><b>cd ~user:</b> перейти в домашнюю директорию пользователя user</li>\n    <li><b>cd -:</b> перейти в директорию, в которой находились до перехода в текущую директорию</li>\n    <li><b>pwd:</b> показать текущую директорию</li>\n    <li><b>ls:</b> отобразить содержимое текущей директории</li>\n    <li><b>ls -F:</b> отобразить содержимое текущей директории с добавлением к именам символов, характеризующих тип</li>\n    <li><b>ls -l:</b> показать детализированное представление файлов и директорий в текущей директории</li>\n    <li><b>ls -a:</b> показать скрытые файлы и директории в текущей директории</li>\n    <li><b>ls *[0-9]*:</b> показать файлы и директории содержащие в имени цифры</li>\n    <li><b>tree или lstree:</b> показать дерево файлов и директорий, начиная от корня (/)</li>\n    <li><b>mkdir dir1:</b> создать директорию с именем 'dir1'</li>\n    <li><b>mkdir dir1 dir2:</b> создать две директории одновременно</li>\n    <li><b>mkdir -p /tmp/dir1/dir2:</b> создать дерево директорий</li>\n    <li><b>rm -f file1:</b> удалить файл с именем 'file1'</li>\n    <li><b>rmdir dir1:</b> удалить директорию с именем 'dir1'</li>\n    <li><b>rm -rf dir1:</b> удалить директорию с именем 'dir1' и рекурсивно всё её содержимое</li>\n    <li><b>rm -rf dir1 dir2:</b> удалить две директории и рекурсивно их содержимое</li>\n    <li><b>mv dir1 new_dir:</b> переименовать или переместить файл или директорию</li>\n    <li><b>cp file1 file2:</b> скопировать файл file1 в файл file2</li>\n    <li><b>cp dir/* .:</b> копировать все файлы директории dir в текущую директорию</li>\n    <li><b>cp -a /tmp/dir1 .:</b> копировать директорию dir1 со всем содержимым в текущую директорию</li>\n    <li><b>cp -a dir1 dir2:</b> копировать директорию dir1 в директорию dir2</li>\n    <li><b>ln -s file1 lnk1*:</b> создать символическую ссылку на файл или директорию</li>\n    <li><b>ln file1 lnk1:</b> создать «жёсткую» (физическую) ссылку на файл или директорию</li>\n    <li><b>touch -t 0712250000 fileditest:</b> модифицировать дату и время создания файла, при его отсутствии, создать\n        файл с указанными датой и временем (YYMMDDhhmm)</li>\n</ui>\n<h3 class=\"gh\">\n    Поиск файлов:\n</h3>\n<ui>\n    <li><b>find / -name file1:</b> найти файлы и директории с именем file1. Поиск начать с корня (/)</li>\n    <li><b>find / -user user1:</b> найти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)\n    </li>\n    <li><b>find /home/user1 -name \"*.bin\":</b> найти все файлы и директории, имена которых оканчиваются на '. bin'.\n        Поиск начать с '/ home/user1'*</li>\n    <li><b>find /usr/bin -type f -atime +100:</b> найти все файлы в '/usr/bin', время последнего обращения к которым\n        более 100 дней</li>\n    <li><b>find /usr/bin -type f -mtime -10:</b> найти все файлы в '/usr/bin', созданные или изменённые в течении\n        последних 10 дней</li>\n    <li><b>find / -name *.rpm -exec chmod 755 '{}' ;:</b> найти все фалы и директории, имена которых оканчиваются на\n        '.rpm', и изменить права доступа к ним</li>\n    <li><b>find / -xdev -name \"*.rpm\":</b> найти все фалы и директории, имена которых оканчиваются на '.rpm', игнорируя\n        съёмные носители, такие как cdrom, floppy и т.п.</li>\n    <li><b>locate \"*.ps\":</b> найти все файлы, содержащие в имени '.ps'. Предварительно рекомендуется выполнить команду\n        'updatedb'</li>\n    <li><b>whereis halt:</b> показывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу\n        'halt'</li>\n    <li><b>which halt:</b> отображает полный путь к файлу 'halt'</li>\n</ui>\n<h3 class=\"gh\">\n    Монтирование файловых систем:\n</h3>\n<ui>\n    <li><b>mount /dev/hda2 /mnt/hda2:</b> монтирует раздел 'hda2' в точку монтирования '/mnt/hda2'. Убедитесь в наличии\n        директории-точки монтирования '/mnt/hda2'</li>\n    <li><b>umount /dev/hda2:</b> размонтирует раздел 'hda2'. Перед выполнением, покиньте '/mnt/hda2'</li>\n    <li><b>fuser -km /mnt/hda2:</b> принудительное размонтирование раздела. Применяется в случае, когда раздел занят\n        каким-либо пользователем</li>\n    <li><b>umount -n /mnt/hda2:</b> выполнить размонтирование без занесения информации в /etc/mtab. Полезно когда файл\n        имеет атрибуты «только чтение» или недостаточно места на диске</li>\n    <li><b>mount /dev/fd0 /mnt/floppy:</b> монтировать флоппи-диск</li>\n    <li><b>mount /dev/cdrom /mnt/cdrom:</b> монтировать CD или DVD</li>\n    <li><b>mount /dev/hdc /mnt/cdrecorder:</b> монтировать CD-R/CD-RW или DVD-R/DVD-RW(+-)</li>\n    <li><b>mount -o loop file.iso /mnt/cdrom:</b> смонтировать ISO-образ</li>\n    <li><b>mount -t vfat /dev/hda5 /mnt/hda5:</b> монтировать файловую систему Windows FAT32</li>\n    <li><b>mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share:</b> монтировать сетевую файловую\n        систему Windows (SMB/CIFS)</li>\n    <li><b>mount -o bind /home/user/prg /var/ftp/user:</b> «монтирует» директорию в директорию (binding). Доступна с\n        версии ядра 2.4.0. Полезна, например, для предоставления содержимого пользовательской директории через ftp при\n        работе ftp-сервера в «песочнице» (chroot), когда симлинки сделать невозможно. Выполнение данной команды сделает\n        копию содержимого /home/user/prg в /var/ftp/user</li>\n</ui>\n<h3 class=\"gh\">\n    Дисковое пространство:\n</h3>\n<ui>\n    <li><b>df -h:</b> отображает информацию о смонтированных разделах с отображением общего, доступного и используемого\n        пространства (Прим. переводчика. ключ -h работает не во всех *nix системах)</li>\n    <li><b>ls -lSr |more:</b> выдаёт список файлов и директорий рекурсивно с сортировкой по возрастанию размера и\n        позволяет осуществлять постраничный просмотр</li>\n    <li><b>du -sh dir1:</b> подсчитывает и выводит размер, занимаемый директорией 'dir1' (Прим. переводчика. ключ -h\n        работает не во всех *nix системах)</li>\n    <li><b>du -sk * | sort -rn:</b> отображает размер и имена файлов и директорий, с соритровкой по размеру</li>\n    <li><b>rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n:</b> показывает размер используемого дискового\n        пространства, занимаемое файлами rpm-пакета, с сортировкой по размеру (fedora, redhat и т.п.)</li>\n    <li><b>dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n:</b> показывает размер используемого\n        дискового пространства, занимаемое файлами deb-пакета, с сортировкой по размеру (ubuntu, debian т.п.)</li>\n</ui>\n\n<h3 class=\"gh\">\n    Пользователи и группы:\n</h3>\n<ui>\n    <li><b>groupadd group_name:</b> создать новую группу с именем group_name</li>\n    <li><b>groupdel group_name:</b> удалить группу group_name</li>\n    <li><b>groupmod -n new_group_name old_group_name:</b> переименовать группу old_group_name в new_group_name</li>\n    <li><b>useradd -c \"Nome Cognome\" -g admin -d /home/user1 -s /bin/bash user1:</b> создать пользователя user1,\n        назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу\n        admin и добавить комментарий Nome Cognome</li>\n    <li><b>useradd user1:</b> создать пользователя user1</li>\n    <li><b>userdel -r user1:</b> удалить пользователя user1 и его домашний каталог</li>\n    <li><b>usermod -c \"User FTP\" -g system -d /ftp/user1 -s /bin/nologin user1:</b> изменить атрибуты пользователя</li>\n    <li><b>passwd:</b> сменить пароль</li>\n    <li><b>passwd user1:</b> сменить пароль пользователя user1 (только root)</li>\n    <li><b>chage -E 2005-12-31 user1:</b> установить дату окончания действия учётной записи пользователя user1</li>\n    <li><b>pwck:</b> проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и\n        /etc/shadow</li>\n    <li><b>grpck:</b> проверяет корректность системных файлов учётных записей. Проверяется файл/etc/group</li>\n    <li><b>newgrp [-] group_name:</b> изменяет первичную группу текущего пользователя. Если указать «-», ситуация будет\n        идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная\n        группа будет назначена из /etc/passwd</li>\n</ui>\n<h3 class=\"gh\">\n    Выставление/изменение полномочий на файлы:\n</h3>\n<ui>\n    <li><b>ls -lh:</b> просмотр полномочий на файлы и директории в текущей директории</li>\n    <li><b>ls /tmp | pr -T5 -W$COLUMNS:</b> вывести содержимое директории /tmp и разделить вывод на пять колонок</li>\n    <li><b>chmod ugo+rwx directory1:</b> добавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read\n        Write eXecute) — всем полные права. Аналогичное можно сделать таким образом chmod 777 directory1</li>\n    <li><b>chmod go-rwx directory1:</b> отобрать у группы и всех остальных все полномочия на директорию directory1.</li>\n    <li><b>chown user1 file1:</b> назначить владельцем файла file1 пользователя user1</li>\n    <li><b>chown -R user1 directory1:</b> назначить рекурсивно владельцем директории directory1 пользователя user1</li>\n    <li><b>chgrp group1 file1:</b> сменить группу-владельца файла file1 на group1</li>\n    <li><b>chown user1:group1 file1:</b> сменить владельца и группу владельца файла file1</li>\n    <li><b>find / -perm -u+s:</b> найти, начиная от корня, все файлы с выставленным SUID</li>\n    <li><b>chmod u+s /bin/binary_file:</b> назначить SUID-бит файлу /bin/binary_file. Это даёт возможность любому\n        пользователю запускать на выполнение файл с полномочиями владельца файла.</li>\n    <li><b>chmod u-s /bin/binary_file:</b> снять SUID-бит с файла /bin/binary_file.</li>\n    <li><b>chmod g+s /home/public:</b> назначить SGID-бит директории /home/public.</li>\n    <li><b>chmod g-s /home/public:</b> снять SGID-бит с директории /home/public.</li>\n    <li><b>chmod o+t /home/public:</b> назначить STIKY-бит директории /home/public. Позволяет удалять файлы только\n        владельцам</li>\n    <li><b>chmod o-t /home/public:</b> снять STIKY-бит с директории /home/public</li>\n</ui>\n<h3 class=\"gh\">\n    Специальные атрибуты файлов:\n</h3>\n<ui>\n    <li><b>chattr +a file1:</b> позволить открывать файл на запись только в режиме добавления</li>\n    <li><b>chattr +c file1:</b> позволяет ядру автоматически сжимать/разжимать содержимое файла.</li>\n    <li><b>chattr +d file1:</b> указывает утилите dump игнорировать данный файл во время выполнения backup'а</li>\n    <li><b>chattr +i file1:</b> делает файл недоступным для любых изменений: редактирование, удаление, перемещение,\n        создание линков на него.</li>\n    <li><b>chattr +s file1:</b> позволяет сделать удаление файла безопасным, т.е. выставленный атрибут s говорит о том,\n        что при удалении файла, место, занимаемое файлом на диске заполняется нулями, что предотвращает возможность\n        восстановления данных.</li>\n    <li><b>chattr +S file1:</b> указывает, что, при сохранении изменений, будет произведена синхронизация, как при\n        выполнении команды sync</li>\n    <li><b>chattr +u file1:</b> данный атрибут указывает, что при удалении файла содержимое его будет сохранено и при\n        необходимости пользователь сможет его восстановить</li>\n    <li><b>lsattr:</b> показать атрибуты файлов</li>\n</ui>\n<h3 class=\"gh\">\n    Архивирование и сжатие файлов:\n</h3>\n<ui>\n    <li><b>bunzip2 file1.bz2:</b> разжимает файл 'file1.gz'</li>\n    <li><b>gunzip file1.gz:</b></li>\n    <li><b>gzip file1 или bzip2 file1:</b> сжимает файл 'file1'</li>\n    <li><b>gzip -9 file1:</b> сжать файл file1 с максимальным сжатием</li>\n    <li><b>rar a file1.rar test_file:</b> создать rar-архив 'file1.rar' и включить в него файл test_file</li>\n    <li><b>rar a file1.rar file1 file2 dir1:</b> создать rar-архив 'file1.rar' и включить в него file1, file2 и dir1\n    </li>\n    <li><b>rar x file1.rar:</b> распаковать rar-архив</li>\n    <li><b>unrar x file1.rar:</b></li>\n    <li><b>tar -cvf archive.tar file1:</b> создать tar-архив archive.tar, содержащий файл file1</li>\n    <li><b>tar -cvf archive.tar file1 file2 dir1:</b> создать tar-архив archive.tar, содержащий файл file1, file2 и dir1\n    </li>\n    <li><b>tar -tf archive.tar:</b> показать содержимое архива</li>\n    <li><b>tar -xvf archive.tar:</b> распаковать архив</li>\n    <li><b>tar -xvf archive.tar -C /tmp:</b> распаковать архив в /tmp</li>\n    <li><b>tar -cvfj archive.tar.bz2 dir1:</b> создать архив и сжать его с помощью bzip2(Прим. переводчика. ключ -j\n        работает не во всех *nix системах)</li>\n    <li><b>tar -xvfj archive.tar.bz2:</b> разжать архив и распаковать его(Прим. переводчика. ключ -j работает не во всех\n        *nix системах)</li>\n    <li><b>tar -cvfz archive.tar.gz dir1:</b> создать архив и сжать его с помощью gzip</li>\n    <li><b>tar -xvfz archive.tar.gz:</b> разжать архив и распаковать его</li>\n    <li><b>zip file1.zip file1:</b> создать сжатый zip-архив</li>\n    <li><b>zip -r file1.zip file1 file2 dir1:</b> создать сжатый zip-архив и со включением в него нескольких файлов\n        и/или директорий</li>\n    <li><b>unzip file1.zip:</b> разжать и распаковать zip-архив</li>\n</ui>\n<h3 class=\"gh\">\n    RPM пакеты (Fedora, Red Hat и тому подобное):\n</h3>\n<ui>\n    <li><b>rpm -ivh package.rpm:</b> установить пакет с выводом сообщений и прогресс-бара</li>\n    <li><b>rpm -ivh --nodeps package.rpm:</b> установить пакет с выводом сообщений и прогресс-бара без контроля\n        зависимостей</li>\n    <li><b>rpm -U package.rpm:</b> обновить пакет без изменений конфигурационных файлов, в случае отсутствия пакета, он\n        будет установлен</li>\n    <li><b>rpm -F package.rpm:</b> обновить пакет только если он установлен</li>\n    <li><b>rpm -e package_name.rpm:</b> удалить пакет</li>\n    <li><b>rpm -qa:</b> отобразить список всех пакетов, установленных в системе</li>\n    <li><b>rpm -qa | grep httpd:</b> среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени\n        «httpd»</li>\n    <li><b>rpm -qi package_name:</b> вывести информацию о конкретном пакете</li>\n    <li><b>rpm -qg \"System Environment/Daemons\":</b> отобразить пакеты входящие в группу пакетов</li>\n    <li><b>rpm -ql package_name:</b> вывести список файлов, входящих в пакет</li>\n    <li><b>rpm -qc package_name:</b> вывести список конфигурационных файлов, входящих в пакет</li>\n    <li><b>rpm -q package_name --whatrequires:</b> вывести список пакетов, необходимых для установки конкретного пакета\n        по зависимостям</li>\n    <li><b>rpm -q package_name --whatprovides:</b> show capability provided by a rpm package</li>\n    <li><b>rpm -q package_name --scripts:</b> отобразит скрипты, запускаемые при установке/удалении пакета</li>\n    <li><b>rpm -q package_name --changelog:</b> вывести историю ревизий пакета</li>\n    <li><b>rpm -qf /etc/httpd/conf/httpd.conf:</b> проверить какому пакету принадлежит указанный файл. Указывать следует\n        полный путь и имя файла.</li>\n    <li><b>rpm -qp package.rpm -l:</b> отображает список файлов, входящих в пакет, но ещё не установленных в систему\n    </li>\n    <li><b>rpm --import /media/cdrom/RPM-GPG-KEY:</b> импортировать публичный ключ цифровой подписи</li>\n    <li><b>rpm --checksig package.rpm:</b> проверит подпись пакета</li>\n    <li><b>rpm -qa gpg-pubkey:</b> проверить целостность установленного содержимого пакета</li>\n    <li><b>rpm -V package_name:</b> проверить размер, полномочия, тип, владельца, группу, MD5-сумму и дату последнего\n        изменеия пакета</li>\n    <li><b>rpm -Va:</b> проверить содержимое всех пакеты установленные в систему. Выполняйте с осторожностью!</li>\n    <li><b>rpm -Vp package.rpm:</b> проверить пакет, который ещё не установлен в систему</li>\n    <li><b>rpm2cpio package.rpm | cpio --extract --make-directories *bin*:</b> извлечь из пакета файлы содержащие в\n        своём имени bin</li>\n    <li><b>rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm:</b> установить пакет, собранный из исходных кодов</li>\n    <li><b>rpmbuild --rebuild package_name.src.rpm:</b> собрать пакет из исходных кодов</li>\n</ui>\n<h3 class=\"gh\">\n    YUM — средство обновления пакетов(Fedora, RedHat и тому подобное):\n</h3>\n<ui>\n    <li><b>yum install package_name:</b> закачать и установить пакет</li>\n    <li><b>yum update:</b> обновить все пакеты, установленные в систему</li>\n    <li><b>yum update package_name:</b> обновить пакет</li>\n    <li><b>yum remove package_name:</b> удалить пакет</li>\n    <li><b>yum list:</b> вывести список всех пакетов, установленных в систему</li>\n    <li><b>yum search package_name:</b> найти пакет в репозиториях</li>\n    <li><b>yum clean packages:</b> очисть rpm-кэш, удалив закачанные пакеты</li>\n    <li><b>yum clean headers:</b> удалить все заголовки файлов, которые система использует для разрешения зависимостей\n    </li>\n    <li><b>yum clean all:</b> очисть rpm-кэш, удалив закачанные пакеты и заголовки</li>\n</ui>\n<h3 class=\"gh\">\n    DEB пакеты (Debian, Ubuntu и тому подобное):\n</h3>\n<ui>\n    <li><b>dpkg -i package.deb:</b> установить / обновить пакет</li>\n    <li><b>dpkg -r package_name:</b> удалить пакет из системы</li>\n    <li><b>dpkg -l:</b> показать все пакеты, установленные в систему</li>\n    <li><b>dpkg -l | grep httpd:</b> среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени\n        «httpd»</li>\n    <li><b>dpkg -s package_name:</b> отобразить информацию о конкретном пакете</li>\n    <li><b>dpkg -L package_name:</b> вывести список файлов, входящих в пакет, установленный в систему</li>\n    <li><b>dpkg --contents package.deb:</b> отобразить список файлов, входящих в пакет, который ещё не установлен в\n        систему</li>\n    <li><b>dpkg -S /bin/ping:</b> найти пакет, в который входит указанный файл.</li>\n</ui>\n<h3 class=\"gh\">\n    APT — средство управление пакетами (Debian, Ubuntu и тому подобное):\n</h3>\n<ui>\n    <li><b>apt update:</b> получить обновлённые списки пакетов</li>\n    <li><b>apt upgrade:</b> обновить пакеты, установленные в систему</li>\n    <li><b>apt install package_name:</b> установить / обновить пакет</li>\n    <li><b>apt-cdrom install package_name:</b> установить / обновить пакет с cdrom'а</li>\n    <li><b>apt remove package_name:</b> удалить пакет, установленный в систему с сохранением файлов конфигурации</li>\n    <li><b>apt purge package_name:</b> удалить пакет, установленный в систему с удалением файлов конфигурации</li>\n    <li><b>apt check:</b> проверить целостность зависимостей</li>\n    <li><b>apt clean:</b> удалить загруженные архивные файлы пакетов</li>\n    <li><b>apt autoclean:</b> удалить старые загруженные архивные файлы пакетов</li>\n</ui>\n<h3 class=\"gh\">\n    Pacman — средство управление пакетами (Arch, Frugalware и alike)\n</h3>\n<ui>\n    <li><b>pacman -S name:</b> install package «name» with dependencies</li>\n    <li><b>pacman -R name:</b> delete package «name» and all files of it</li>\n</ui>\n<h3 class=\"gh\">\n    Просмотр содержимого файлов:\n</h3>\n<ui>\n    <li><b>cat file1:</b> вывести содержимое файла file1 на стандартное устройство вывода</li>\n    <li><b>tac file1:</b> вывести содержимое файла file1 на стандартное устройство вывода в обратном порядке (последняя\n        строка становиться первой и т.д.)</li>\n    <li><b>more file1:</b> постраничный вывод содержимого файла file1 на стандартное устройство вывода</li>\n    <li><b>less file1:</b> постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с\n        возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.</li>\n    <li><b>head -2 file1:</b> вывести первые две строки файла file1 на стандартное устройство вывода. По умолчанию\n        выводится десять строк</li>\n    <li><b>tail -2 file1:</b> вывести последние две строки файла file1 на стандартное устройство вывода. По умолчанию\n        выводится десять строк</li>\n    <li><b>tail -f /var/log/messages:</b> выводить содержимое файла /var/log/messages на стандартное устройство вывода\n        по мере появления в нём текста.</li>\n</ui>\n<h3 class=\"gh\">\n    Манипуляции с текстом:\n</h3>\n<ui>\n    <li><b>grep -HR OLDTEXT ./ | awk '{print $1}' | sed 's/:.*$//' | grep -v '~' | sort | uniq | xargs perl -i -pe\n            \"s/OLD_TEXT/NEW_TEXT/g;\":</b> Поиск и замена текста OLDTEXT на NEW_TEXT во многих файлах одновременно с\n        рекурсивным обходом директорий.</li>\n    <li><b>cat file_originale | [operation: sed, grep, awk, grep и т.п.] > result.txt:</b> общий синтаксис выполнения\n        действий по обработке содержимого файла и вывода результата в новый</li>\n    <li><b>cat file_originale | [operazione: sed, grep, awk, grepи т.п.] >> result.txt:</b> общий синтаксис выполнения\n        действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он\n        будет создан</li>\n    <li><b>grep Aug /var/log/messages:</b> из файла '/var/log/messages' отобрать и вывести на стандартное устройство\n        вывода строки, содержащие «Aug»</li>\n    <li><b>grep ^Aug /var/log/messages:</b> из файла '/var/log/messages' отобрать и вывести на стандартное устройство\n        вывода строки, начинающиеся на «Aug»</li>\n    <li><b>grep [0-9] /var/log/messages:</b> из файла '/var/log/messages' отобрать и вывести на стандартное устройство\n        вывода строки, содержащие цифры</li>\n    <li><b>grep Aug -R /var/log/*:</b> отобрать и вывести на стандартное устройство вывода строки, содержащие «Augr», во\n        всех файлах, находящихся в директории /var/log и ниже</li>\n    <li><b>sed 's/stringa1/stringa2/g' example.txt:</b> в файле example.txt заменить «string1» на «string2», результат\n        вывести на стандартное устройство вывода.</li>\n    <li><b>sed '/^$/d' example.txt:</b> удалить пустые строки из файла example.txt</li>\n    <li><b>sed '/ *#/d; /^$/d' example.txt:</b> удалить пустые строки и комментарии из файла example.txt</li>\n    <li><b>echo 'esempio' | tr '[:lower:]' '[:upper:]':</b> преобразовать символы из нижнего регистра в верхний</li>\n    <li><b>sed -e '1d' result.txt:</b> удалить первую строку из файла example.txt</li>\n    <li><b>sed -n '/string1/p':</b> отобразить только строки, содержащие «string1»</li>\n    <li><b>sed -e 's/ *$//' example.txt:</b> удалить пустые символы в конце каждой строки</li>\n    <li><b>sed -e 's/string1//g' example.txt:</b> удалить строку «string1» из текста не изменяя всего остального</li>\n    <li><b>sed -n '1,8p;5q' example.txt:</b> взять из файла с первой по восьмую строки и из них вывести первые пять</li>\n    <li><b>sed -n '5p;5q' example.txt:</b> вывести пятую строку</li>\n    <li><b>sed -e 's/0*/0/g' example.txt:</b> заменить последовательность из любого количества нулей одним нулём</li>\n    <li><b>cat -n file1:</b> пронумеровать строки при выводе содержимого файла</li>\n    <li><b>cat example.txt | awk 'NR%2==1':</b> при выводе содержимого файла, не выводить чётные строки файла</li>\n    <li><b>echo a b c | awk '{print $1}':</b> вывести первую колонку. Разделение, по умолчанию, по пробелу/пробелам или\n        символу/символам табуляции</li>\n    <li><b>echo a b c | awk '{print $1,$3}':</b> вывести первую и третью колонки. Разделение, по умолчанию, по\n        проблелу/пробелам или символу/символам табуляции</li>\n    <li><b>paste file1 file2:</b> объединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1\n        колонка 1-n, строка 1 из file2 = строка 1 колонка n+1-m</li>\n    <li><b>paste -d '+' file1 file2:</b> объединить содержимое file1 и file2 в виде таблицы с разделителем «+»</li>\n    <li><b>sort file1 file2:</b> отсортировать содержимое двух файлов</li>\n    <li><b>sort file1 file2 | uniq:</b> отсортировать содержимое двух файлов, не отображая повторов</li>\n    <li><b>sort file1 file2 | uniq -u:</b> отсортировать содержимое двух файлов, отображая только уникальные строки\n        (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)</li>\n    <li><b>sort file1 file2 | uniq -d:</b> отсортировать содержимое двух файлов, отображая только повторяющиеся строки\n    </li>\n    <li><b>comm -1 file1 file2:</b> сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file1'\n    </li>\n    <li><b>comm -2 file1 file2:</b> сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file2'\n    </li>\n    <li><b>comm -3 file1 file2:</b> сравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах</li>\n</ui>\n<h3 class=\"gh\">\n    Преобразование наборов символов и файловых форматов:\n</h3>\n<ui>\n    <li><b>dos2unix filedos.txt fileunix.txt:</b> конвертировать файл текстового формата из MSDOS в UNIX (разница в\n        символах возврата каретки)</li>\n    <li><b>unix2dos fileunix.txt filedos.txt:</b> конвертировать файл текстового формата из UNIX в MSDOS (разница в\n        символах возврата каретки)</li>\n    <li><b>recode ..HTML < page.txt> page.html:</b> конвертировать содержимое тестового файла page.txt в html-файл\n        page.html</li>\n    <li><b>recode -l | more:</b> вывести список доступных форматов</li>\n</ui>\n<h3 class=\"gh\">\n    Анализ файловых систем:\n</h3>\n<ui>\n    <li><b>badblocks -v /dev/hda1:</b> проверить раздел hda1 на наличие bad-блоков</li>\n    <li><b>fsck /dev/hda1:</b> проверить/восстановить целостность linux-файловой системы раздела hda1</li>\n    <li><b>fsck.ext2 /dev/hda1 или e2fsck /dev/hda1:</b> проверить/восстановить целостность файловой системы ext2\n        раздела hda1</li>\n    <li><b>e2fsck -j /dev/hda1:</b> проверить/восстановить целостность файловой системы ext3 раздела hda1 с указанием,\n        что журнал расположен там же</li>\n    <li><b>fsck.ext3 /dev/hda1:</b> проверить/восстановить целостность файловой системы ext3 раздела hda1</li>\n    <li><b>fsck.vfat /dev/hda1 или fsck.msdos /dev/hda1 или dosfsck /dev/hda1:</b> проверить/восстановить целостность\n        файловой системы fat раздела hda11</li>\n</ui>\n<h3 class=\"gh\">\n    Форматирование файловых систем:\n</h3>\n<ui>\n    <li><b>mkfs /dev/hda1:</b> создать linux-файловую систему на разделе hda1</li>\n    <li><b>mke2fs /dev/hda1:</b> создать файловую систему ext2 на разделе hda1</li>\n    <li><b>mke2fs -j /dev/hda1:</b> создать журналирующую файловую систему ext3 на разделе hda1</li>\n    <li><b>mkfs -t vfat 32 -F /dev/hda1:</b> создать файловую систему FAT32 на разделе hda1</li>\n    <li><b>fdformat -n /dev/fd0:</b> форматирование флоппи-диска без проверки</li>\n    <li><b>mkswap /dev/hda3:</b> создание swap-пространства на разделе hda3</li>\n</ui>\n<h3 class=\"gh\">\n    swap-пространство:\n</h3>\n<ui>\n    <li><b>mkswap /dev/hda3:</b> создание swap-пространства на разделе hda3</li>\n    <li><b>swapon /dev/hda3:</b> активировать swap-пространство, расположенное на разделе hda3</li>\n    <li><b>swapon /dev/hda2 /dev/hdb3:</b> активировать swap-пространства, расположенные на разделах hda2 и hdb3</li>\n</ui>\n<h3 class=\"gh\">\n    Создание резервных копий (backup):\n</h3>\n<ui>\n    <li><b>dump -0aj -f /tmp/home0.bak /home:</b> создать полную резервную копию директории /home в файл /tmp/home0.bak\n    </li>\n    <li><b>dump -1aj -f /tmp/home0.bak /home:</b> создать инкрементальную резервную копию директории /home в файл\n        /tmp/home0.bak</li>\n    <li><b>restore -if /tmp/home0.bak:</b> восстановить из резервной копии /tmp/home0.bak</li>\n    <li><b>rsync -rogpav --delete /home /tmp:</b> синхронизировать /tmp с /home</li>\n    <li><b>rsync -rogpav -e ssh --delete /home ip_address:/tmp:</b> синхронизировать через SSH-туннель</li>\n    <li><b>rsync -az -e ssh --delete ip_addr:/home/public /home/local:</b> синхронизировать локальную директорию с\n        удалённой директорией через ssh-туннель со сжатием</li>\n    <li><b>rsync -az -e ssh --delete /home/local ip_addr:/home/public:</b> синхронизировать удалённую директорию с\n        локальной директорией через ssh-туннель со сжатием</li>\n    <li><b>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz':</b> сделать «слепок» локального диска в файл\n        на удалённом компьютере через ssh-туннель</li>\n    <li><b>tar -Puf backup.tar /home/user:</b> создать инкрементальную резервную копию директории '/home/user' в файл\n        backup.tar с сохранением полномочий</li>\n    <li><b>( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p':</b> копирование\n        содержимого /tmp/local на удалённый компьютер через ssh-туннель в /home/share/</li>\n    <li><b>( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p':</b> копирование содержимого /home\n        на удалённый компьютер через ssh-туннель в /home/backup-home</li>\n    <li><b>tar cf - . | (cd /tmp/backup ; tar xf - ):</b> копирование одной директории в другую с сохранением полномочий\n        и линков</li>\n    <li><b>find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents:</b> поиск в\n        /home/user1 всех файлов, имена которых оканчиваются на '.txt', и копирование их в другую директорию</li>\n    <li><b>find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2:</b> поиск в /var/log всех файлов,\n        имена которых оканчиваются на '.log', и создание bzip-архива из них</li>\n    <li><b>dd if=/dev/hda of=/dev/fd0 bs=512 count=1:</b> создать копию MBR (Master Boot Record) с /dev/hda на\n        флоппи-диск</li>\n    <li><b>dd if=/dev/fd0 of=/dev/hda bs=512 count=1:</b> восстановить MBR с флоппи-диска на /dev/hda</li>\n</ui>\n<h3 class=\"gh\">\n    CDROM:\n</h3>\n<ui>\n    <li><b>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force:</b> clean a rewritable cdrom</li>\n    <li><b>mkisofs /dev/cdrom > cd.iso:</b> create an iso image of cdrom on disk</li>\n    <li><b>mkisofs /dev/cdrom | gzip > cd_iso.gz:</b> create a compressed iso image of cdrom on disk</li>\n    <li><b>mkisofs -J -allow-leading-dots -R -V \"Label CD\" -iso-level 4 -o ./cd.iso data_cd:</b> create an iso image of\n        a directory</li>\n    <li><b>cdrecord -v dev=/dev/cdrom cd.iso:</b> burn an ISO image</li>\n    <li><b>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom:</b> burn a compressed ISO image</li>\n    <li><b>mount -o loop cd.iso /mnt/iso:</b> mount an ISO image</li>\n    <li><b>cd-paranoia -B:</b> rip audio tracks from a CD to wav files</li>\n    <li><b>cd-paranoia -- \"-3\":</b> rip first three audio tracks from a CD to wav files</li>\n    <li><b>cdrecord --scanbus:</b> scan bus to identify the channel scsi</li>\n</ui>\n<h3 class=\"gh\">\n    Сеть (LAN и WiFi):\n</h3>\n<ui>\n    <li><b>ifconfig eth0:</b> показать конфигурацию сетевого интерфейса eth0</li>\n    <li><b>ifup eth0:</b> активировать (поднять) интерфейс eth0</li>\n    <li><b>ifdown eth0:</b> деактивировать (опустить) интерфейс eth0</li>\n    <li><b>ifconfig eth0 192.168.1.1 netmask 255.255.255.0:</b> выставить интерфейсу eth0 IP-адрес и маску подсети</li>\n    <li><b>ifconfig eth0 promisc:</b> перевести интерфейс eth0 в promiscuous-режим для «отлова» пакетов (sniffing)</li>\n    <li><b>ifconfig eth0 -promisc:</b> отключить promiscuous-режим на интерфейсе eth0</li>\n    <li><b>dhclient eth0:</b> активировать интерфейс eth0 в dhcp-режиме.</li>\n    <li><b>route -:</b></li>\n    <li><b>netstat -rn:</b> вывести локальную таблицу маршрутизации</li>\n    <li><b>route add -net 0/0 gw IP_Gateway:</b> задать IP-адрес шлюза по умолчанию (default gateway)</li>\n    <li><b>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1:</b> добавить статический маршрут в сеть\n        192.168.0.0/16 через шлюз с IP-адресом 192.168.1.1</li>\n    <li><b>route del 0/0 gw IP_gateway:</b> удалить IP-адрес шлюза по умолчанию (default gateway)</li>\n    <li><b>echo \"1\" > /proc/sys/net/ipv4/ip_forward:</b> разрешить пересылку пакетов (forwarding)</li>\n    <li><b>hostname:</b> отобразить имя компьютера</li>\n    <li><b>host www.example.com или host 192.0.43.10:</b> разрешить имя www.example.com хоста в IP-адрес и наоборот</li>\n    <li><b>ip link show:</b> отобразить состояние всех интерфейсов</li>\n    <li><b>mii-tool eth0:</b> отобразить статус и тип соединения для интерфейса eth0</li>\n    <li><b>ethtool eth0:</b> отображает статистику интерфейса eth0 с выводом такой информации, как поддерживаемые и\n        текущие режимы соединения</li>\n    <li><b>netstat -tupn:</b> отображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения\n        имён в IP-адреса и PID'ы и имена процессов, обеспечивающих эти соединения</li>\n    <li><b>netstat -tupln:</b> отображает все сетевые соединения по протоколам TCP и UDP без разрешения имён в IP-адреса\n        и PID'ы и имена процессов, слушающих порты</li>\n    <li><b>tcpdump tcp port 80:</b> отобразить весь трафик на TCP-порт 80 (обычно — HTTP)</li>\n    <li><b>iwlist scan:</b> просканировать эфир на предмет, доступности беспроводных точек доступа</li>\n    <li><b>iwconfig eth1:</b> показать конфигурацию беспроводного сетевого интерфейса eth1</li>\n</ui>\n<h3 class=\"gh\">\n    Microsoft Windows networks(SAMBA)\n</h3>\n<ui>\n    <li><b>nbtscan ip_add:</b></li>\n    <li><b>nmblookup -A ip_addr:</b> разрешить netbios-имя nbtscan не во всех системах ставится по умолчанию, возможно,\n        придётся доустанавливать вручную. nmblookup включён в пакет samba.</li>\n    <li><b>smbclient -L ip_addr/hostname:</b> отобразить ресурсы, предоставленные в общий доступ на windows-машине</li>\n    <li><b>smbget -Rr smb://ip_addr/share:</b> подобно wget может получить файлы с windows-машин через smb-протокол</li>\n    <li><b>mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share:</b> смонтировать smb-ресурс,\n        предоставленный на windows-машине, в локальную файловую систему</li>\n</ui>\n<h3 class=\"gh\">\n    IPTABLES (firewall):\n</h3>\n<ui>\n    <li><b>iptables -t filter -n:</b></li>\n    <li><b>iptables -nL:</b> отобразить все цепочки правил</li>\n    <li><b>iptables -t nat -L:</b> отобразить все цепочки правил в NAT-таблице</li>\n    <li><b>iptables -t filter -F или iptables -F:</b> очистить все цепочки правил в filter-таблице</li>\n    <li><b>iptables -t nat -F:</b> очистить все цепочки правил в NAT-таблице</li>\n    <li><b>iptables -t filter -X:</b> удалить все пользовательские цепочки правил в filter-таблице</li>\n    <li><b>iptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT:</b> позволить входящее подключение telnet'ом\n    </li>\n    <li><b>iptables -t filter -A OUTPUT -p tcp --dport http -j DROP:</b> блокировать исходящие HTTP-соединения</li>\n    <li><b>iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT:</b> позволить «прокидывать» (forward)\n        POP3-соединения</li>\n    <li><b>iptables -t filter -A INPUT -j LOG --log-prefix \"DROP INPUT\":</b> включить журналирование ядром пакетов,\n        проходящих через цепочку INPUT, и добавлением к сообщению префикса «DROP INPUT»</li>\n    <li><b>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE:</b> включить NAT (Network Address Translate) исходящих\n        пакетов на интерфейс eth0. Допустимо при использовании с динамически выделяемыми IP-адресами.</li>\n    <li><b>iptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 -j DNAT --to-destination\n            10.0.0.2:22:</b> перенаправление пакетов, адресованных одному хосту, на другой хост</li>\n</ui>\n<h3 class=\"gh\">\n    Мониторинг и отладка:\n</h3>\n<ui>\n    <li><b>top:</b> отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (с\n        автоматическим обновлением данных)</li>\n    <li><b>ps -eafw:</b> отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию\n        (единожды)</li>\n    <li><b>ps -e -o pid,args --forest:</b> вывести PID'ы и процессы в виде дерева</li>\n    <li><b>pstree:</b> отобразить дерево процессов</li>\n    <li><b>kill -9 98989 или kill -KILL 98989:</b> «убить» процесс с PID 98989 «на смерть» (без соблюдения целостности\n        данных)</li>\n    <li><b>kill -TERM 98989:</b> корректно завершить процесс с PID 98989</li>\n    <li><b>kill -1 98989 или kill -HUP 98989:</b> заставить процесс с PID 98989 перепрочитать файл конфигурации</li>\n    <li><b>lsof -p 98989:</b> отобразить список файлов, открытых процессом с PID 98989</li>\n    <li><b>lsof /home/user1:</b> отобразить список открытых файлов из директории /home/user1</li>\n    <li><b>strace -c ls >/dev/null:</b> вывести список системных вызовов, созданных и полученных процессом ls</li>\n    <li><b>strace -f -e open ls >/dev/null:</b> вывести вызовы библиотек</li>\n    <li><b>watch -n1 'cat /proc/interrupts':</b> отображать прерывания в режиме реального времени</li>\n    <li><b>last reboot:</b> отобразить историю перезагрузок системы</li>\n    <li><b>last user1:</b> отобразить историю регистрации пользователя user1 в системе и время его нахождения в ней</li>\n    <li><b>lsmod:</b> вывести загруженные модули ядра</li>\n    <li><b>free -m:</b> показать состояние оперативной памяти в мегабайтах</li>\n    <li><b>smartctl -A /dev/hda:</b> контроль состояния жёсткого диска /dev/hda через SMART</li>\n    <li><b>smartctl -i /dev/hda:</b> проверить доступность SMART на жёстком диске /dev/hda</li>\n    <li><b>tail /var/log/dmesg:</b> вывести десять последних записей из журнала загрузки ядра</li>\n    <li><b>tail /var/log/messages:</b> вывести десять последних записей из системного журнала</li>\n</ui>\n<h3 class=\"gh\">\n    Мониторинг и отладка:\n</h3>\n<ui>\n    <li><b>apropos …keyword:</b> выводит список команд, которые так или иначе относятся к ключевым словам. Полезно,\n        когда вы знаете что делает программа, но не помните команду</li>\n    <li><b>man ping:</b> вызов руководства по работе с программой, в данном случае, — ping</li>\n    <li><b>whatis …keyword:</b> отображает описание действий указанной программы</li>\n    <li><b>mkbootdisk --device /dev/fd0 `uname -r`:</b> создаёт загрузочный флоппи-диск</li>\n    <li><b>gpg -c file1:</b> шифрует файл file1 с помощью GNU Privacy Guard</li>\n    <li><b>gpg file1.gpg:</b> дешифрует файл file1 с помощью GNU Privacy Guard</li>\n    <li><b>wget -r http://www.example.com:</b> загружает рекурсивно содержимое сайта http://www.example.com</li>\n    <li><b>wget -c http://www.example.com/file.iso:</b> загрузить файл http://www.example.com/file.iso с возможностью\n        останова и продолжения в последствии</li>\n    <li><b>echo 'wget -c http://www.example.com/files.iso' | at 09:00:</b> начать закачку в указанное время</li>\n    <li><b>ldd /usr/bin/ssh:</b> вывести список библиотек, необходимых для работы ssh</li>\n    <li><b>alias hh='history':</b> назначить алиас hh команде history</li>\n</ui>",
        "author": "admin",
        "userId": 1,
        "category": "bash",
        "image": "linux_bash.jpg",
        "create": "23.07.2022 03:59:00",
        "update": "28.08.2022 09:45:34",
        "active": true
    }
]